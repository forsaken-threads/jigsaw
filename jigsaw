#!/usr/bin/env php
<?php

use Illuminate\Contracts\Events\Dispatcher;
use Illuminate\Support\Arr;
use Illuminate\View\Compilers\BladeCompiler;
use Illuminate\View\Engines\CompilerEngine;
use Illuminate\View\Engines\EngineResolver;
use Illuminate\View\Factory;
use Illuminate\View\FileViewFinder;
use TightenCo\Jigsaw\Console\BuildCommand;
use TightenCo\Jigsaw\Console\InitCommand;
use TightenCo\Jigsaw\Console\ServeCommand;
use TightenCo\Jigsaw\Filesystem;
use TightenCo\Jigsaw\Handlers\BladeHandler;
use TightenCo\Jigsaw\Handlers\DefaultHandler;
use TightenCo\Jigsaw\Handlers\MarkdownHandler;
use TightenCo\Jigsaw\Jigsaw;
use TightenCo\Jigsaw\PuzzleBox;
use TightenCo\Jigsaw\TemporaryFilesystem;

if (file_exists(__DIR__.'/vendor/autoload.php')) {
    require __DIR__.'/vendor/autoload.php';
} else {
    require __DIR__.'/../../autoload.php';
}

// Config
$cachePath = getcwd() . '/_tmp';
$buildPath = getcwd() . '/build';
$sourcePath = getcwd() . '/source';
$config = include getcwd() . '/config.php';

$container = new PuzzleBox();

// Bind our TemporaryFilesystem into the container so anyone can use it
$container->instance(TemporaryFilesystem::class, new TemporaryFilesystem($cachePath));

// Gather up the Puzzle Piece plugins, including the built-in file handlers
$puzzlePieces = array_merge(
    [BladeHandler::class, MarkdownHandler::class, DefaultHandler::class],
    Arr::get($config, '_puzzle_pieces', [])
);

// This will tag the Puzzle Pieces in the container and run any register methods if they exist
$container->registerPuzzlePieces($puzzlePieces);

// Bind the BladeCompiler instance to the container so custom directives/extensions can be created
$container->instance(BladeCompiler::class, new BladeCompiler(new Filesystem, $cachePath));

// Bind the View Factory as a singleton
$container->singleton(Factory::class, function ($c) use ($sourcePath) {
    $resolver = new EngineResolver;

    $resolver->register('blade', function () use ($c) {
        return new CompilerEngine($c[BladeCompiler::class], new Filesystem);
    });

    $finder = new FileViewFinder(new Filesystem, [$sourcePath]);
    return new Factory($resolver, $finder, Mockery::mock(Dispatcher::class)->shouldIgnoreMissing());
});

// This will run any boot methods on the bindings tagged as a Puzzle Piece.
// It will also tag special Puzzle Pieces like File Handlers and Build Decorators
$container->bootPuzzlePieces();

$jigsaw = new Jigsaw(new Filesystem, $cachePath);

$jigsaw->registerHandlers($container->tagged('jigsaw.file_handler'));
$jigsaw->registerDefaultHandler($container[DefaultHandler::class]);

$jigsaw->registerBuildDecorators($container->tagged('jigsaw.build_decorator'));

$buildCommand = new BuildCommand($jigsaw, $sourcePath, $buildPath);

$app = new Symfony\Component\Console\Application('Jigsaw', '0.6.0');
$app->add($buildCommand);
$app->add($container[InitCommand::class]);
$app->add($container[ServeCommand::class]);
$app->run();
